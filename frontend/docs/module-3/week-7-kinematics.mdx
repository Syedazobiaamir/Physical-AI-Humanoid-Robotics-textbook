---
sidebar_position: 1
title: "Week 7: Robot Kinematics"
description: "Understanding forward and inverse kinematics for robotic manipulators"
---

import ChapterQuiz from '@site/src/components/ChapterQuiz';
import ChatSelection from '@site/src/components/ChatSelection';

# Week 7: Robot Kinematics

<ChatSelection chapterId="week-7-kinematics">

## Learning Objectives

By the end of this chapter, you will be able to:

1. Understand forward kinematics and transformation matrices
2. Apply Denavit-Hartenberg (DH) convention to robot arms
3. Solve inverse kinematics problems for robotic manipulators
4. Implement kinematic solutions in ROS2
5. Visualize robot configurations in RViz

## Introduction

Kinematics is the study of motion without considering forces. In robotics, we use kinematics to describe the relationship between joint positions and the end-effector pose.

### Forward vs Inverse Kinematics

```
Forward Kinematics: Joint Angles → End-Effector Pose
Inverse Kinematics: End-Effector Pose → Joint Angles
```

## Theory: Transformation Matrices

### Homogeneous Transformation

A 4x4 homogeneous transformation matrix represents both rotation and translation:

```
T = | R  p |
    | 0  1 |

where R is a 3x3 rotation matrix and p is a 3x1 position vector
```

### Rotation Matrices

**Rotation about Z-axis:**
```
Rz(θ) = | cos(θ)  -sin(θ)  0 |
        | sin(θ)   cos(θ)  0 |
        |   0        0     1 |
```

### Denavit-Hartenberg Convention

The DH convention provides a systematic way to assign coordinate frames:

| Parameter | Description |
|-----------|-------------|
| θ (theta) | Joint angle (rotation about z-axis) |
| d | Link offset (translation along z-axis) |
| a | Link length (translation along x-axis) |
| α (alpha) | Link twist (rotation about x-axis) |

## Lab Tasks

### Task 1: Implement Forward Kinematics

Create a ROS2 package for forward kinematics:

```python
# forward_kinematics.py
import numpy as np
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Pose
from sensor_msgs.msg import JointState

class ForwardKinematics(Node):
    def __init__(self):
        super().__init__('forward_kinematics')
        self.subscription = self.create_subscription(
            JointState,
            'joint_states',
            self.joint_callback,
            10
        )
        self.pose_pub = self.create_publisher(Pose, 'end_effector_pose', 10)

        # DH parameters for a 3-DOF arm [theta, d, a, alpha]
        self.dh_params = [
            [0, 0.1, 0, np.pi/2],    # Joint 1
            [0, 0, 0.3, 0],           # Joint 2
            [0, 0, 0.25, 0]           # Joint 3
        ]

    def dh_matrix(self, theta, d, a, alpha):
        """Compute DH transformation matrix"""
        ct, st = np.cos(theta), np.sin(theta)
        ca, sa = np.cos(alpha), np.sin(alpha)

        return np.array([
            [ct, -st*ca,  st*sa, a*ct],
            [st,  ct*ca, -ct*sa, a*st],
            [0,   sa,     ca,    d],
            [0,   0,      0,     1]
        ])

    def compute_fk(self, joint_angles):
        """Compute end-effector pose from joint angles"""
        T = np.eye(4)
        for i, params in enumerate(self.dh_params):
            theta = joint_angles[i] + params[0]
            d, a, alpha = params[1], params[2], params[3]
            T = T @ self.dh_matrix(theta, d, a, alpha)
        return T

    def joint_callback(self, msg):
        if len(msg.position) >= 3:
            T = self.compute_fk(msg.position[:3])
            pose = Pose()
            pose.position.x = T[0, 3]
            pose.position.y = T[1, 3]
            pose.position.z = T[2, 3]
            self.pose_pub.publish(pose)

def main(args=None):
    rclpy.init(args=args)
    node = ForwardKinematics()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Task 2: Inverse Kinematics Solver

Implement an analytical IK solver:

```python
# inverse_kinematics.py
import numpy as np
from typing import List, Optional

class InverseKinematics:
    def __init__(self, l1: float, l2: float):
        """
        Initialize IK solver for 2-link planar arm

        Args:
            l1: Length of first link
            l2: Length of second link
        """
        self.l1 = l1
        self.l2 = l2

    def solve(self, x: float, y: float) -> Optional[List[float]]:
        """
        Solve IK for target position

        Returns:
            List of [theta1, theta2] or None if unreachable
        """
        # Check reachability
        d = np.sqrt(x**2 + y**2)
        if d > self.l1 + self.l2 or d < abs(self.l1 - self.l2):
            return None

        # Cosine law for elbow angle
        cos_theta2 = (x**2 + y**2 - self.l1**2 - self.l2**2) / (2*self.l1*self.l2)
        theta2 = np.arccos(np.clip(cos_theta2, -1, 1))

        # Shoulder angle
        k1 = self.l1 + self.l2 * np.cos(theta2)
        k2 = self.l2 * np.sin(theta2)
        theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)

        return [theta1, theta2]
```

### Task 3: Visualize in RViz

Create a URDF model and launch file:

```xml
<!-- robot.urdf -->
<?xml version="1.0"?>
<robot name="simple_arm">
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.1 0.1 0.05"/>
      </geometry>
    </visual>
  </link>

  <joint name="joint_1" type="revolute">
    <parent link="base_link"/>
    <child link="link_1"/>
    <origin xyz="0 0 0.025"/>
    <axis xyz="0 0 1"/>
    <limit lower="-3.14" upper="3.14" effort="100" velocity="1"/>
  </joint>

  <link name="link_1">
    <visual>
      <origin xyz="0.15 0 0"/>
      <geometry>
        <box size="0.3 0.05 0.05"/>
      </geometry>
    </visual>
  </link>
</robot>
```

## Code Examples

### NumPy Kinematics Library

```python
# kinematics_lib.py
import numpy as np

def rotation_x(angle):
    """Rotation matrix about X-axis"""
    c, s = np.cos(angle), np.sin(angle)
    return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])

def rotation_y(angle):
    """Rotation matrix about Y-axis"""
    c, s = np.cos(angle), np.sin(angle)
    return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])

def rotation_z(angle):
    """Rotation matrix about Z-axis"""
    c, s = np.cos(angle), np.sin(angle)
    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])

def euler_to_rotation(roll, pitch, yaw):
    """Convert Euler angles (ZYX) to rotation matrix"""
    return rotation_z(yaw) @ rotation_y(pitch) @ rotation_x(roll)

def rotation_to_euler(R):
    """Extract Euler angles from rotation matrix"""
    sy = np.sqrt(R[0,0]**2 + R[1,0]**2)
    singular = sy < 1e-6

    if not singular:
        roll = np.arctan2(R[2,1], R[2,2])
        pitch = np.arctan2(-R[2,0], sy)
        yaw = np.arctan2(R[1,0], R[0,0])
    else:
        roll = np.arctan2(-R[1,2], R[1,1])
        pitch = np.arctan2(-R[2,0], sy)
        yaw = 0

    return roll, pitch, yaw
```

## Summary

In this chapter, we covered:

- Forward kinematics using transformation matrices
- The Denavit-Hartenberg convention for systematic frame assignment
- Inverse kinematics solutions for robotic manipulators
- Implementation of kinematic algorithms in ROS2
- Visualization of robot configurations

## Additional Resources

- [ROS2 tf2 Documentation](https://docs.ros.org/en/humble/Concepts/About-Tf2.html)
- [Modern Robotics: Mechanics, Planning, and Control](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)
- [MoveIt 2 Documentation](https://moveit.ros.org/)

</ChatSelection>

## Chapter Quiz

<ChapterQuiz chapterId="week-7-kinematics" />
