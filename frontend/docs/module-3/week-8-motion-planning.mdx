---
sidebar_position: 2
title: "Week 8: Motion Planning"
description: "Learn path planning algorithms and trajectory generation for robots"
---

import ChapterQuiz from '@site/src/components/ChapterQuiz';
import ChatSelection from '@site/src/components/ChatSelection';

# Week 8: Motion Planning

<ChatSelection chapterId="week-8-motion-planning">

## Learning Objectives

By the end of this chapter, you will be able to:

1. Understand configuration space and obstacle representation
2. Implement sampling-based planners (RRT, PRM)
3. Apply trajectory optimization techniques
4. Use MoveIt 2 for motion planning in ROS2
5. Handle dynamic obstacles and replanning

## Introduction

Motion planning answers the question: "How can a robot move from point A to point B while avoiding obstacles?" This fundamental problem underlies all autonomous robot behavior.

### Configuration Space

The configuration space (C-space) represents all possible robot configurations:

```
C-space = {q : q represents a valid robot configuration}
C-free = C-space - C-obstacle (collision-free configurations)
```

## Theory: Planning Algorithms

### Rapidly-exploring Random Trees (RRT)

RRT builds a tree by randomly sampling and extending toward samples:

```
Algorithm RRT:
1. Initialize tree T with start configuration
2. While goal not reached:
   a. Sample random configuration q_rand
   b. Find nearest node q_near in T
   c. Extend from q_near toward q_rand to get q_new
   d. If q_new is collision-free, add to T
3. Return path from start to goal
```

### Probabilistic Roadmap (PRM)

PRM constructs a graph of collision-free configurations:

```
Algorithm PRM:
1. Sample n random configurations
2. Keep collision-free samples
3. Connect nearby samples with edges
4. Remove edges that collide
5. Query path using graph search
```

### RRT* (Optimal RRT)

RRT* improves on RRT with rewiring for asymptotic optimality:

```python
def rewire(tree, q_new, neighbors, cost_func):
    """Rewire tree to improve path costs"""
    for q_near in neighbors:
        new_cost = cost(q_new) + edge_cost(q_new, q_near)
        if new_cost < cost(q_near):
            if collision_free(q_new, q_near):
                tree.set_parent(q_near, q_new)
```

## Lab Tasks

### Task 1: Implement Basic RRT

Create an RRT planner in Python:

```python
# rrt_planner.py
import numpy as np
from typing import List, Tuple, Optional

class RRTPlanner:
    def __init__(self, bounds: Tuple, step_size: float = 0.1):
        """
        Initialize RRT planner

        Args:
            bounds: ((x_min, x_max), (y_min, y_max))
            step_size: Maximum step size for extension
        """
        self.bounds = bounds
        self.step_size = step_size
        self.nodes = []
        self.parents = {}

    def sample_random(self) -> np.ndarray:
        """Sample random configuration"""
        x = np.random.uniform(self.bounds[0][0], self.bounds[0][1])
        y = np.random.uniform(self.bounds[1][0], self.bounds[1][1])
        return np.array([x, y])

    def nearest(self, q: np.ndarray) -> int:
        """Find nearest node index"""
        distances = [np.linalg.norm(q - node) for node in self.nodes]
        return np.argmin(distances)

    def steer(self, q_near: np.ndarray, q_rand: np.ndarray) -> np.ndarray:
        """Steer from q_near toward q_rand"""
        direction = q_rand - q_near
        distance = np.linalg.norm(direction)
        if distance <= self.step_size:
            return q_rand
        return q_near + (direction / distance) * self.step_size

    def plan(self, start: np.ndarray, goal: np.ndarray,
             is_collision_free, max_iters: int = 1000) -> Optional[List[np.ndarray]]:
        """
        Plan path from start to goal

        Args:
            start: Start configuration
            goal: Goal configuration
            is_collision_free: Function to check collision
            max_iters: Maximum iterations

        Returns:
            Path as list of configurations or None
        """
        self.nodes = [start]
        self.parents = {0: None}

        for _ in range(max_iters):
            # Bias toward goal 10% of time
            if np.random.random() < 0.1:
                q_rand = goal
            else:
                q_rand = self.sample_random()

            near_idx = self.nearest(q_rand)
            q_near = self.nodes[near_idx]
            q_new = self.steer(q_near, q_rand)

            if is_collision_free(q_near, q_new):
                new_idx = len(self.nodes)
                self.nodes.append(q_new)
                self.parents[new_idx] = near_idx

                # Check if goal reached
                if np.linalg.norm(q_new - goal) < self.step_size:
                    return self._extract_path(new_idx)

        return None

    def _extract_path(self, goal_idx: int) -> List[np.ndarray]:
        """Extract path from tree"""
        path = []
        idx = goal_idx
        while idx is not None:
            path.append(self.nodes[idx])
            idx = self.parents[idx]
        return path[::-1]
```

### Task 2: Integrate with MoveIt 2

Create a MoveIt 2 planning interface:

```python
# moveit_planning.py
import rclpy
from rclpy.node import Node
from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import MotionPlanRequest, Constraints
from geometry_msgs.msg import PoseStamped
from rclpy.action import ActionClient

class MoveItPlanner(Node):
    def __init__(self):
        super().__init__('moveit_planner')
        self._action_client = ActionClient(
            self, MoveGroup, 'move_action'
        )

    def plan_to_pose(self, target_pose: PoseStamped):
        """Plan motion to target pose"""
        goal_msg = MoveGroup.Goal()
        goal_msg.request = MotionPlanRequest()
        goal_msg.request.group_name = 'arm'
        goal_msg.request.num_planning_attempts = 10
        goal_msg.request.allowed_planning_time = 5.0

        # Set goal constraints
        goal_msg.request.goal_constraints.append(
            self._pose_to_constraints(target_pose)
        )

        self._action_client.wait_for_server()
        return self._action_client.send_goal_async(goal_msg)

    def _pose_to_constraints(self, pose: PoseStamped) -> Constraints:
        """Convert pose to MoveIt constraints"""
        constraints = Constraints()
        # Add position and orientation constraints
        # ... (implementation details)
        return constraints

def main(args=None):
    rclpy.init(args=args)
    planner = MoveItPlanner()

    target = PoseStamped()
    target.header.frame_id = 'base_link'
    target.pose.position.x = 0.4
    target.pose.position.y = 0.0
    target.pose.position.z = 0.3

    future = planner.plan_to_pose(target)
    rclpy.spin_until_future_complete(planner, future)

    planner.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Task 3: Trajectory Smoothing

Implement trajectory optimization:

```python
# trajectory_smoother.py
import numpy as np
from scipy.interpolate import CubicSpline

def smooth_trajectory(waypoints: np.ndarray,
                      num_points: int = 100) -> np.ndarray:
    """
    Smooth waypoints using cubic spline interpolation

    Args:
        waypoints: Array of shape (N, D) for N waypoints in D dimensions
        num_points: Number of output points

    Returns:
        Smoothed trajectory
    """
    t = np.linspace(0, 1, len(waypoints))
    t_smooth = np.linspace(0, 1, num_points)

    smooth_path = np.zeros((num_points, waypoints.shape[1]))
    for dim in range(waypoints.shape[1]):
        cs = CubicSpline(t, waypoints[:, dim])
        smooth_path[:, dim] = cs(t_smooth)

    return smooth_path

def time_parameterize(path: np.ndarray,
                      max_vel: float,
                      max_acc: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Add time parameterization with velocity/acceleration limits

    Returns:
        (timestamps, velocities)
    """
    # Compute segment lengths
    segments = np.diff(path, axis=0)
    lengths = np.linalg.norm(segments, axis=1)

    # Trapezoidal velocity profile
    timestamps = [0.0]
    velocities = [0.0]

    for length in lengths:
        # Time for constant acceleration phase
        t_acc = max_vel / max_acc
        d_acc = 0.5 * max_acc * t_acc**2

        if 2 * d_acc > length:
            # Triangle profile
            t = np.sqrt(length / max_acc)
            timestamps.append(timestamps[-1] + 2*t)
        else:
            # Trapezoidal profile
            d_const = length - 2*d_acc
            t_const = d_const / max_vel
            timestamps.append(timestamps[-1] + 2*t_acc + t_const)

        velocities.append(max_vel)

    return np.array(timestamps), np.array(velocities)
```

## Code Examples

### Collision Checking

```python
# collision_checker.py
import numpy as np
from typing import List, Tuple

class CollisionChecker:
    def __init__(self, obstacles: List[Tuple[np.ndarray, float]]):
        """
        Initialize collision checker

        Args:
            obstacles: List of (center, radius) for circular obstacles
        """
        self.obstacles = obstacles

    def check_point(self, point: np.ndarray) -> bool:
        """Check if point is collision-free"""
        for center, radius in self.obstacles:
            if np.linalg.norm(point - center) <= radius:
                return False
        return True

    def check_line(self, start: np.ndarray, end: np.ndarray,
                   resolution: int = 10) -> bool:
        """Check if line segment is collision-free"""
        for t in np.linspace(0, 1, resolution):
            point = start + t * (end - start)
            if not self.check_point(point):
                return False
        return True
```

## Summary

In this chapter, we covered:

- Configuration space representation
- Sampling-based planning algorithms (RRT, PRM)
- Trajectory optimization and smoothing
- Integration with MoveIt 2 for ROS2
- Collision checking for motion planning

## Additional Resources

- [Planning Algorithms by Steven LaValle](http://lavalle.pl/planning/)
- [MoveIt 2 Tutorials](https://moveit.picknik.ai/main/index.html)
- [OMPL Library](https://ompl.kavrakilab.org/)

</ChatSelection>

## Chapter Quiz

<ChapterQuiz chapterId="week-8-motion-planning" />
